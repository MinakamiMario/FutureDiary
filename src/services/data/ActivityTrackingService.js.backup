/**
 * UNIFIED ACTIVITY TRACKING SERVICE
 * 
 * Consolidates all activity and health tracking:
 * - activityService.js (435 lines)
 * - locationService.js (404 lines) 
 * - healthDataService.js (982 lines)
 * 
 * Single source of truth for user tracking data with modular architecture
 */

import database from '../database';
import errorLogger from '../errorLogger';
import performanceService from '../performanceService';
import { BaseService } from '../BaseService';
import platformDetector from '../../utils/platformDetector';
import GetLocation from 'react-native-get-location';
import { NativeModules, NativeEventEmitter, Platform } from 'react-native';

const { SensorManager, HealthConnectModule, RealHealthConnectModule } = NativeModules;

// Configuration constants
const LOCATION_INTERVAL = 300000; // 5 minutes
const SIGNIFICANT_DISTANCE = 100; // 100 meters
const ACCELEROMETER_INTERVAL = 200; // 200ms

// Activity tracking constants
const SAMPLE_RATE = 5; // 5 samples per seconde (200ms)
const DETECTION_INTERVAL = 10000; // 10 seconden
const STEP_THRESHOLD = 10; // Drempel voor herkenning van een stap
const ACTIVITY_DETECTION = 'activity-detection';

// Health Connect setup
let HealthConnect;
if (__DEV__) {
  HealthConnect = HealthConnectModule;
} else {
  HealthConnect = RealHealthConnectModule;
}

/**
 * Real Accelerometer Implementation
 * Handles both real sensors and mock data fallback
 */
class RealAccelerometer {
  constructor() {
    this.listeners = [];
    this.isListening = false;
    this.intervalId = null;
    this.sensorSubscription = null;
  }

  addListener(callback) {
    this.listeners.push(callback);
    if (!this.isListening) {
      this.startListening();
    }
    return {
      remove: () => {
        this.listeners = this.listeners.filter(l => l !== callback);
        if (this.listeners.length === 0) {
          this.stopListening();
        }
      }
    };
  }

  startListening() {
    this.isListening = true;
    
    // Try to use real sensors first
    try {
      if (SensorManager && SensorManager.startAccelerometer) {
        // Use real accelerometer
        const eventEmitter = new NativeEventEmitter(SensorManager);
        this.sensorSubscription = eventEmitter.addListener('Accelerometer', (data) => {
          this.listeners.forEach(listener => listener(data));
        });
        SensorManager.startAccelerometer(200); // 200ms interval
      } else {
        throw new Error('Native sensors not available');
      }
    } catch (error) {
      if (typeof __DEV__ !== 'undefined' && __DEV__) {
        console.warn('Real accelerometer not available, using mock data:', error);
        // Fallback to mock data only in development on emulator
        this.intervalId = setInterval(() => {
          const mockData = {
            x: (Math.random() - 0.5) * 2,
            y: (Math.random() - 0.5) * 2,
            z: (Math.random() - 0.5) * 2
          };
          this.listeners.forEach(listener => listener(mockData));
        }, 200);
      } else {
        // Production on real device - don't use mock data, report error
        console.error('ActivityService: Accelerometer not available on real device');
        throw error; // Re-throw error for proper handling
      }
    }
  }

  stopListening() {
    this.isListening = false;
    
    // Stop real sensor if available
    if (this.sensorSubscription) {
      this.sensorSubscription.remove();
      this.sensorSubscription = null;
      if (SensorManager && SensorManager.stopAccelerometer) {
        SensorManager.stopAccelerometer();
      }
    }
    
    // Stop mock data interval
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  setUpdateInterval(interval) {
    // Mock implementation - doesn't actually change interval
  }
}

class ActivityTrackingService extends BaseService {
  constructor() {
    super('ActivityTrackingService');
    
    // Tracking state
    this.isTracking = false;
    this.lastLocation = null;
    this.locationTrackingInterval = null;
    this.accelerometerSubscription = null;
    this.platformInfo = null;
    this.currentSession = null;
    
    // Sub-modules for organization
    this.activity = new ActivityModule(this);
    this.location = new LocationModule(this);
    this.health = new HealthModule(this);
    
    this.initializePlatform();
  }

  async initializePlatform() {
    try {
      this.platformInfo = await platformDetector.detectPlatform();
    } catch (error) {
      console.warn('Platform detection failed:', error);
      this.platformInfo = { isEmulator: false, shouldUseMockData: false };
    }
  }

  // ============================================
  // UNIFIED TRACKING METHODS
  // ============================================

  /**
   * Unified tracking session - combines activity, location, and health data
   */
  async startTrackingSession(options = {}) {
    const start = performanceService?.startTracking?.('activityTracking.startSession');
    
    try {
      this.isTracking = true;
      
      // Start all sub-module tracking
      await Promise.all([
        this.activity.startActivityMonitoring(options.activity),
        this.location.startLocationTracking(options.location),
        this.health.startHealthSync(options.health)
      ]);
      
      performanceService?.endTracking?.(start);
      return { success: true, sessionId: Date.now() };
    } catch (error) {
      performanceService?.endTracking?.(start, error);
      errorLogger.error('Failed to start tracking session', error);
      throw error;
    }
  }

  async stopTrackingSession() {
    const start = performanceService?.startTracking?.('activityTracking.stopSession');
    
    try {
      this.isTracking = false;
      
      // Stop all sub-module tracking
      await Promise.all([
        this.activity.stopActivityMonitoring(),
        this.location.stopLocationTracking(),
        this.health.stopHealthSync()
      ]);
      
      performanceService?.endTracking?.(start);
      return { success: true };
    } catch (error) {
      performanceService?.endTracking?.(start, error);
      errorLogger.logError('Failed to stop tracking session', error);
      throw error;
    }
  }

  /**
   * Get comprehensive daily tracking data
   */
  async getDailyTrackingData(date) {
    const start = performanceService?.startTracking?.('activityTracking.getDailyData');
    
    try {
      const startOfDay = new Date(date);
      startOfDay.setHours(0, 0, 0, 0);
      const endOfDay = new Date(date);
      endOfDay.setHours(23, 59, 59, 999);
      
      const [activities, locations, healthData] = await Promise.all([
        this.activity.getActivities(startOfDay.getTime(), endOfDay.getTime()),
        this.location.getLocations(startOfDay.getTime(), endOfDay.getTime()),
        this.health.getHealthStats(date)
      ]);
      
      const unifiedData = {
        date: date.toISOString().split('T')[0],
        activities: activities,
        locations: locations,
        health: healthData,
        summary: this.generateDailySummary(activities, locations, healthData),
        metadata: {
          totalActivities: activities.length,
          totalLocations: locations.length,
          trackingCoverage: this.calculateTrackingCoverage(activities, locations, healthData),
          generatedAt: Date.now()
        }
      };
      
      performanceService?.endTracking?.(start);
      return unifiedData;
    } catch (error) {
      performanceService?.endTracking?.(start, error);
      errorLogger.logError('Failed to get daily tracking data', error);
      throw error;
    }
  }

  /**
   * Batch operations for efficient data processing
   */
  async batchLogActivities(activities) {
    return this.activity.batchLogActivities(activities);
  }

  async batchTrackLocations(locations) {
    return this.location.batchTrackLocations(locations);
  }

  async batchSyncHealthData(dates) {
    return this.health.batchSyncHealthData(dates);
  }

  // ============================================
  // LEGACY COMPATIBILITY METHODS
  // ============================================

  // Activity service compatibility
  async logActivity(activity) {
    return this.activity.logActivity(activity);
  }

  async getActivities(startTimestamp, endTimestamp) {
    return this.activity.getActivities(startTimestamp, endTimestamp);
  }

  async getActivitiesForDate(date) {
    return this.activity.getActivitiesForDate(date);
  }

  async updateActivity(activityId, updates) {
    return this.activity.updateActivity(activityId, updates);
  }

  async deleteActivity(activityId) {
    return this.activity.deleteActivity(activityId);
  }

  // Location service compatibility
  async trackLocation(location) {
    return this.location.trackLocation(location);
  }

  async getLocations(startTimestamp, endTimestamp) {
    return this.location.getLocations(startTimestamp, endTimestamp);
  }

  async getVisitedPlaces(startTimestamp, endTimestamp) {
    return this.location.getVisitedPlaces(startTimestamp, endTimestamp);
  }

  async getRecentLocations(limit = 10) {
    return this.location.getRecentLocations(limit);
  }

  // Health data service compatibility
  async syncHealthData(date) {
    return this.health.syncHealthData(date);
  }

  async getHealthStats(date) {
    return this.health.getHealthStats(date);
  }

  async getHealthDataForDateRange(startDate, endDate) {
    return this.health.getHealthDataForDateRange(startDate, endDate);
  }

  // ============================================
  // UTILITY METHODS
  // ============================================

  generateDailySummary(activities, locations, healthData) {
    return {
      totalSteps: this.calculateTotalSteps(activities),
      totalCalories: this.calculateTotalCalories(activities),
      totalDistance: this.calculateTotalDistance(activities),
      activeMinutes: this.calculateActiveMinutes(activities),
      uniquePlacesVisited: this.countUniquePlaces(locations),
      mostActiveTime: this.findMostActiveTime(activities),
      locationCoverage: this.calculateLocationCoverage(locations),
      healthScore: this.calculateHealthScore(activities, healthData)
    };
  }

  calculateTrackingCoverage(activities, locations, healthData) {
    const hasActivities = activities && activities.length > 0;
    const hasLocations = locations && locations.length > 0;
    const hasHealthData = healthData && Object.keys(healthData).length > 0;
    
    let coverage = 0;
    if (hasActivities) coverage += 0.4;
    if (hasLocations) coverage += 0.3;
    if (hasHealthData) coverage += 0.3;
    
    return Math.round(coverage * 100);
  }

  calculateTotalSteps(activities) {
    return activities.reduce((total, activity) => {
      return total + (activity.steps || 0);
    }, 0);
  }

  calculateTotalCalories(activities) {
    return activities.reduce((total, activity) => {
      return total + (activity.calories || 0);
    }, 0);
  }

  calculateTotalDistance(activities) {
    return activities.reduce((total, activity) => {
      return total + (activity.distance || 0);
    }, 0);
  }

  calculateActiveMinutes(activities) {
    return activities.reduce((total, activity) => {
      const minutes = activity.duration ? Math.floor(activity.duration / 60000) : 0;
      return total + minutes;
    }, 0);
  }

  countUniquePlaces(locations) {
    const places = new Set();
    locations.forEach(loc => {
      const key = loc.place_id || `${loc.latitude?.toFixed(4)},${loc.longitude?.toFixed(4)}`;
      places.add(key);
    });
    return places.size;
  }

  findMostActiveTime(activities) {
    if (!activities.length) return null;
    
    const hourCounts = {};
    activities.forEach(activity => {
      const hour = new Date(activity.timestamp).getHours();
      hourCounts[hour] = (hourCounts[hour] || 0) + 1;
    });
    
    const mostActiveHour = Object.keys(hourCounts).reduce((a, b) => 
      hourCounts[a] > hourCounts[b] ? a : b
    );
    
    return `${mostActiveHour}:00-${parseInt(mostActiveHour) + 1}:00`;
  }

  calculateLocationCoverage(locations) {
    if (!locations.length) return 0;
    
    const startTime = Math.min(...locations.map(l => l.timestamp));
    const endTime = Math.max(...locations.map(l => l.timestamp));
    const totalDuration = endTime - startTime;
    const dayDuration = 24 * 60 * 60 * 1000; // 24 hours
    
    return Math.min(100, Math.round((totalDuration / dayDuration) * 100));
  }

  calculateHealthScore(activities, healthData) {
    let score = 0;
    
    // Activity score (0-40 points)
    const steps = this.calculateTotalSteps(activities);
    const stepScore = Math.min(40, (steps / 10000) * 40);
    score += stepScore;
    
    // Health data score (0-30 points)
    if (healthData && healthData.steps) {
      const healthScore = Math.min(30, (healthData.steps / 10000) * 30);
      score += healthScore;
    }
    
    // Active minutes score (0-30 points)
    const activeMinutes = this.calculateActiveMinutes(activities);
    const activeScore = Math.min(30, (activeMinutes / 30) * 30);
    score += activeScore;
    
    return Math.round(score);
  }
}

/**
 * ACTIVITY MODULE
 * Handles activity tracking and step counting with full accelerometer support
 */
class ActivityModule {
  constructor(parent) {
    this.parent = parent;
    this.accelerometerSubscription = null;
    this.isMonitoring = false;
    this.currentActivity = null;
    this.accelerometer = new RealAccelerometer();
    this.stepCount = 0;
    this.lastStepTime = 0;
    this.activityHistory = [];
  }

  async startActivityMonitoring(options = {}) {
    if (this.isMonitoring) return;
    
    try {
      // Initialize accelerometer monitoring
      await this.initializeAccelerometer();
      this.isMonitoring = true;
      
      // Reset counters
      this.stepCount = 0;
      this.lastStepTime = 0;
      this.activityHistory = [];
      
      errorLogger.info('Activity monitoring started');
    } catch (error) {
      errorLogger.logError('Failed to start activity monitoring', error);
      throw error;
    }
  }

  async stopActivityMonitoring() {
    if (!this.isMonitoring) return;
    
    try {
      // Stop accelerometer
      if (this.accelerometer) {
        this.accelerometer.stopListening();
      }
      
      if (this.accelerometerSubscription) {
        this.accelerometerSubscription.remove();
        this.accelerometerSubscription = null;
      }
      
      if (this.currentActivity) {
        await this.endActivity();
      }
      
      this.isMonitoring = false;
      errorLogger.info('Activity monitoring stopped');
    } catch (error) {
      errorLogger.logError('Failed to stop activity monitoring', error);
      throw error;
    }
  }

  async initializeAccelerometer() {
    try {
      // Use the RealAccelerometer class for proper sensor handling
      this.accelerometerSubscription = this.accelerometer.addListener((data) => {
        this.handleAccelerometerData(data);
      });
      errorLogger.info('Accelerometer initialized successfully');
    } catch (error) {
      errorLogger.logError('Failed to initialize accelerometer', error);
      throw error;
    }
  }

  startMockAccelerometer() {
    const mockInterval = setInterval(() => {
      const mockData = {
        x: (Math.random() - 0.5) * 2,
        y: (Math.random() - 0.5) * 2,
        z: (Math.random() - 0.5) * 2 + 9.8,
        timestamp: Date.now()
      };
      this.handleAccelerometerData(mockData);
    }, 200);
    
    this.accelerometerSubscription = { remove: () => clearInterval(mockInterval) };
  }

  handleAccelerometerData(data) {
    // Use advanced accelerometer processing
    this.processAccelerometerData(data);
  }

  async startActivity(type) {
    this.currentActivity = {
      type: type,
      start_time: Date.now(),
      steps: 0,
      calories: 0,
      distance: 0
    };
  }

  async endActivity() {
    if (!this.currentActivity) return;
    
    this.currentActivity.end_time = Date.now();
    this.currentActivity.duration = this.currentActivity.end_time - this.currentActivity.start_time;
    
    // Estimate metrics based on activity type and duration
    this.estimateActivityMetrics(this.currentActivity);
    
    // Save to database
    await this.logActivity(this.currentActivity);
    this.currentActivity = null;
  }

  estimateActivityMetrics(activity) {
    const durationMinutes = activity.duration / 60000;
    
    switch (activity.type) {
      case 'walking':
        activity.steps = Math.round(durationMinutes * 100); // ~100 steps per minute
        activity.calories = Math.round(durationMinutes * 5); // ~5 calories per minute
        activity.distance = Math.round(durationMinutes * 100); // ~100m per minute
        break;
      case 'running':
        activity.steps = Math.round(durationMinutes * 150);
        activity.calories = Math.round(durationMinutes * 12);
        activity.distance = Math.round(durationMinutes * 200);
        break;
      case 'cycling':
        activity.calories = Math.round(durationMinutes * 8);
        activity.distance = Math.round(durationMinutes * 300);
        break;
      default:
        activity.calories = Math.round(durationMinutes * 3);
    }
  }

  // Advanced accelerometer data processing
  processAccelerometerData(data) {
    // Extract features from accelerometer data
    const features = this.extractFeatures(data);
    
    // Classify activity based on features
    const activityType = this.classifyActivity(features);
    
    // Update current activity
    if (activityType !== 'stationary' && !this.currentActivity) {
      this.startActivity(activityType);
    } else if (activityType === 'stationary' && this.currentActivity) {
      this.endActivity();
    }
    
    // Step detection
    this.detectSteps(data);
    
    // Store in history
    this.activityHistory.push({
      timestamp: Date.now(),
      activity: activityType,
      features: features,
      magnitude: Math.sqrt(data.x * data.x + data.y * data.y + data.z * data.z)
    });
    
    // Keep only recent history (last hour)
    const oneHourAgo = Date.now() - 3600000;
    this.activityHistory = this.activityHistory.filter(item => item.timestamp > oneHourAgo);
  }

  extractFeatures(accelerometerData) {
    // Extract movement features from accelerometer data
    const { x, y, z } = accelerometerData;
    
    // Calculate magnitude
    const magnitude = Math.sqrt(x * x + y * y + z * z);
    
    // Calculate variance (movement intensity)
    const variance = (x * x + y * y + z * z) / 3;
    
    // Calculate dominant axis
    const dominantAxis = Math.max(Math.abs(x), Math.abs(y), Math.abs(z));
    
    // Calculate movement pattern
    const pattern = this.calculateMovementPattern(accelerometerData);
    
    return {
      magnitude: magnitude,
      variance: variance,
      dominantAxis: dominantAxis,
      pattern: pattern,
      timestamp: Date.now()
    };
  }

  calculateMovementPattern(data) {
    // Simple pattern recognition based on axis dominance
    const { x, y, z } = data;
    const absX = Math.abs(x);
    const absY = Math.abs(y);
    const absZ = Math.abs(z);
    
    if (absZ > absX && absZ > absY) {
      return 'vertical'; // Walking/running
    } else if (absX > absY) {
      return 'horizontal-x'; // Side to side movement
    } else {
      return 'horizontal-y'; // Forward/backward movement
    }
  }

  classifyActivity(features) {
    const { magnitude, variance, pattern } = features;
    
    // Stationary detection
    if (magnitude < 10.5) {
      return 'stationary';
    }
    
    // Walking detection (moderate magnitude, vertical pattern)
    if (magnitude > 10.5 && magnitude < 13 && pattern === 'vertical') {
      return 'walking';
    }
    
    // Running detection (high magnitude, vertical pattern)
    if (magnitude > 13 && pattern === 'vertical') {
      return 'running';
    }
    
    // Vehicle detection (consistent moderate magnitude)
    if (magnitude > 11 && magnitude < 14 && variance < 2) {
      return 'vehicle';
    }
    
    // Cycling detection (moderate magnitude, horizontal pattern)
    if (magnitude > 11 && magnitude < 14 && (pattern === 'horizontal-x' || pattern === 'horizontal-y')) {
      return 'cycling';
    }
    
    return 'unknown';
  }

  detectSteps(data) {
    // Simple step detection based on magnitude peaks
    const magnitude = Math.sqrt(data.x * data.x + data.y * data.y + data.z * data.z);
    const now = Date.now();
    
    // Detect peak (magnitude above threshold with timing)
    if (magnitude > STEP_THRESHOLD && (now - this.lastStepTime) > 300) { // Min 300ms between steps
      this.stepCount++;
      this.lastStepTime = now;
      
      // Update current activity steps if active
      if (this.currentActivity) {
        this.currentActivity.steps = this.stepCount;
      }
    }
  }

  async requestActivityRecognitionPermission() {
    try {
      // Request activity recognition permission
      const { request, PERMISSIONS, RESULTS } = await import('react-native-permissions');
      const result = await request(PERMISSIONS.ANDROID.ACTIVITY_RECOGNITION);
      return result === RESULTS.GRANTED;
    } catch (error) {
      errorLogger.warn('Activity recognition permission not available', error);
      return true; // Assume granted if permission system not available
    }
  }

  async startMonitoring() {
    try {
      // Request permissions first
      const hasPermission = await this.requestActivityRecognitionPermission();
      if (!hasPermission) {
        throw new Error('Activity recognition permission denied');
      }
      
      // Start activity monitoring
      await this.startActivityMonitoring();
      
      errorLogger.info('Activity monitoring started successfully');
      return { success: true };
    } catch (error) {
      errorLogger.logError('Failed to start monitoring', error);
      throw error;
    }
  }

  async stopMonitoring() {
    try {
      await this.stopActivityMonitoring();
      errorLogger.info('Activity monitoring stopped successfully');
      return { success: true };
    } catch (error) {
      errorLogger.logError('Failed to stop monitoring', error);
      throw error;
    }
  }

  async detectActivity(accelerometerData) {
    // Process single accelerometer data point
    const features = this.extractFeatures(accelerometerData);
    return this.classifyActivity(features);
  }

  async getStepsCount(startDate, endDate) {
    try {
      // Get activities in date range
      const activities = await this.getActivities(startDate.getTime(), endDate.getTime());
      
      // Sum up steps from all activities
      const totalSteps = activities.reduce((total, activity) => {
        return total + (activity.steps || 0);
      }, 0);
      
      return totalSteps;
    } catch (error) {
      errorLogger.logError('Failed to get steps count', error);
      return 0;
    }
  }

  async getActivitySummary(startDate, endDate) {
    try {
      // Get activities in date range
      const activities = await this.getActivities(startDate.getTime(), endDate.getTime());
      
      // Calculate summary statistics
      const summary = {
        totalActivities: activities.length,
        totalSteps: activities.reduce((total, activity) => total + (activity.steps || 0), 0),
        totalCalories: activities.reduce((total, activity) => total + (activity.calories || 0), 0),
        totalDistance: activities.reduce((total, activity) => total + (activity.distance || 0), 0),
        activeMinutes: activities.reduce((total, activity) => {
          const minutes = activity.duration ? Math.floor(activity.duration / 60000) : 0;
          return total + minutes;
        }, 0),
        byType: this.groupBy(activities, 'type')
      };
      
      return summary;
    } catch (error) {
      errorLogger.logError('Failed to get activity summary', error);
      throw error;
    }
  }

  groupBy(array, key) {
    return array.reduce((groups, item) => {
      const group = item[key] || 'unknown';
      groups[group] = groups[group] || [];
      groups[group].push(item);
      return groups;
    }, {});
  }

  // Core activity methods
  async logActivity(activity) {
    const activityData = {
      type: activity.type || 'unknown',
      start_time: activity.start_time || Date.now(),
      end_time: activity.end_time,
      duration: activity.duration,
      sport_type: activity.sport_type,
      distance: activity.distance,
      calories: activity.calories,
      steps: activity.steps,
      metadata: activity.metadata ? JSON.stringify(activity.metadata) : null,
      created_at: Date.now()
    };

    return database.addActivity(activityData);
  }

  async getActivities(startTimestamp, endTimestamp) {
    return database.getActivitiesForDateRange(startTimestamp, endTimestamp);
  }

  async getActivitiesForDate(date) {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);
    
    return this.getActivities(startOfDay.getTime(), endOfDay.getTime());
  }

  async updateActivity(activityId, updates) {
    return database.updateActivity(activityId, updates);
  }

  async deleteActivity(activityId) {
    return database.deleteActivity(activityId);
  }

  async batchLogActivities(activities) {
    const results = [];
    
    for (const activity of activities) {
      try {
        const result = await this.logActivity(activity);
        results.push({ success: true, data: result });
      } catch (error) {
        results.push({ success: false, error: error.message, activity });
      }
    }
    
    return results;
  }
}

/**
 * LOCATION MODULE
 * Handles location tracking and place detection
 */
class LocationModule {
  constructor(parent) {
    this.parent = parent;
    this.isTracking = false;
    this.lastLocation = null;
    this.locationTrackingInterval = null;
  }

  async startLocationTracking(options = {}) {
    if (this.isTracking) return;
    
    try {
      this.isTracking = true;
      
      // Start periodic location updates
      this.startPeriodicLocationUpdates(options);
      
    } catch (error) {
      errorLogger.logError('Failed to start location tracking', error);
      throw error;
    }
  }

  async stopLocationTracking() {
    if (!this.isTracking) return;
    
    try {
      this.isTracking = false;
      
      if (this.locationTrackingInterval) {
        clearInterval(this.locationTrackingInterval);
        this.locationTrackingInterval = null;
      }
      
    } catch (error) {
      errorLogger.logError('Failed to stop location tracking', error);
      throw error;
    }
  }

  startPeriodicLocationUpdates(options = {}) {
    const interval = options.interval || LOCATION_INTERVAL;
    
    this.locationTrackingInterval = setInterval(async () => {
      if (!this.isTracking) return;
      
      try {
        const location = await this.getCurrentPositionAsync(options);
        await this.handleLocationUpdate(location);
      } catch (error) {
        errorLogger.logError('Location update failed', error);
      }
    }, interval);
  }

  async getCurrentPositionAsync(options = {}) {
    // Platform detection for emulator/real device logic
    if (!this.parent.platformInfo) {
      await this.parent.initializePlatform();
    }

    if (this.parent.platformInfo?.shouldUseMockData) {
      return this.getMockLocation();
    }

    // Real device - get actual location
    const location = await GetLocation.getCurrentPosition({
      enableHighAccuracy: options.enableHighAccuracy || false,
      timeout: options.timeout || 15000,
    });
    
    return {
      coords: {
        latitude: location.latitude,
        longitude: location.longitude,
        accuracy: location.accuracy,
        altitude: location.altitude || null,
        heading: location.heading || null,
        speed: location.speed || null
      },
      timestamp: Date.now()
    };
  }

  getMockLocation() {
    return {
      coords: {
        latitude: 52.3676 + (Math.random() - 0.5) * 0.01, // Amsterdam area
        longitude: 4.9041 + (Math.random() - 0.5) * 0.01,
        accuracy: 10 + Math.random() * 20,
        altitude: null,
        heading: null,
        speed: null
      },
      timestamp: Date.now()
    };
  }

  async handleLocationUpdate(location) {
    // Check if location is significantly different from last location
    if (this.lastLocation && !this.isSignificantLocationChange(this.lastLocation, location)) {
      return; // Skip if not significant change
    }
    
    // Get place information
    const placeInfo = await this.getPlaceInfo(location.coords);
    
    const locationData = {
      latitude: location.coords.latitude,
      longitude: location.coords.longitude,
      accuracy: location.coords.accuracy,
      altitude: location.coords.altitude,
      heading: location.coords.heading,
      speed: location.coords.speed,
      timestamp: location.timestamp,
      name: placeInfo.name,
      address: placeInfo.address,
      place_id: placeInfo.place_id,
      created_at: Date.now()
    };

    await this.trackLocation(locationData);
    this.lastLocation = location;
  }

  isSignificantLocationChange(lastLocation, newLocation) {
    if (!lastLocation) return true;
    
    const distance = this.calculateDistance(
      lastLocation.coords.latitude,
      lastLocation.coords.longitude,
      newLocation.coords.latitude,
      newLocation.coords.longitude
    );
    
    return distance > SIGNIFICANT_DISTANCE;
  }

  calculateDistance(lat1, lon1, lat2, lon2) {
    // Haversine formula for distance calculation
    const R = 6371e3; // Earth's radius in meters
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  }

  async getPlaceInfo(coords) {
    // Simple reverse geocoding simulation
    // In production, this would call a real geocoding API
    const mockPlaces = [
      { name: 'Home', address: 'Residential Area', place_id: 'home_001' },
      { name: 'Work', address: 'Business District', place_id: 'work_001' },
      { name: 'Gym', address: 'Fitness Center', place_id: 'gym_001' },
      { name: 'Park', address: 'Public Park', place_id: 'park_001' }
    ];
    
    // Simple place assignment based on coordinates (mock logic)
    const placeIndex = Math.floor(Math.random() * mockPlaces.length);
    return mockPlaces[placeIndex];
  }

  // Core location methods
  async trackLocation(location) {
    return database.addLocation(location);
  }

  async getLocations(startTimestamp, endTimestamp) {
    return database.getLocationsForDateRange(startTimestamp, endTimestamp);
  }

  async getVisitedPlaces(startTimestamp, endTimestamp) {
    const locations = await this.getLocations(startTimestamp, endTimestamp);
    
    // Group by place_id or coordinates to get unique places
    const places = new Map();
    
    locations.forEach(loc => {
      const key = loc.place_id || `${loc.latitude.toFixed(4)},${loc.longitude.toFixed(4)}`;
      
      if (!places.has(key)) {
        places.set(key, {
          ...loc,
          visit_count: 1,
          first_visit: loc.timestamp,
          last_visit: loc.timestamp
        });
      } else {
        const place = places.get(key);
        place.visit_count++;
        place.last_visit = Math.max(place.last_visit, loc.timestamp);
      }
    });
    
    return Array.from(places.values());
  }

  async getRecentLocations(limit = 10) {
    return database.getRecentLocations(limit);
  }

  async batchTrackLocations(locations) {
    const results = [];
    
    for (const location of locations) {
      try {
        const result = await this.trackLocation(location);
        results.push({ success: true, data: result });
      } catch (error) {
        results.push({ success: false, error: error.message, location });
      }
    }
    
    return results;
  }

  // Missing location service methods
  async hasServicesEnabledAsync() {
    // For react-native-get-location, we try to get location to check if enabled
    try {
      await GetLocation.getCurrentPosition({
        enableHighAccuracy: false,
        timeout: 5000,
      });
      return true;
    } catch (error) {
      return false;
    }
  }

  async requestForegroundPermissionsAsync() {
    try {
      // Request location permissions through GetLocation
      await GetLocation.getCurrentPosition({
        enableHighAccuracy: false,
        timeout: 1000,
      });
      return { status: 'granted' };
    } catch (error) {
      return { status: 'denied' };
    }
  }

  async requestBackgroundPermissionsAsync() {
    try {
      // Request background location permissions
      await GetLocation.getCurrentPosition({
        enableHighAccuracy: true,
        timeout: 1000,
      });
      return { status: 'granted' };
    } catch (error) {
      return { status: 'denied' };
    }
  }

  async getForegroundPermissionsAsync() {
    const hasPermission = await this.hasServicesEnabledAsync();
    return { status: hasPermission ? 'granted' : 'denied' };
  }

  async getBackgroundPermissionsAsync() {
    const hasPermission = await this.hasServicesEnabledAsync();
    return { status: hasPermission ? 'granted' : 'denied' };
  }

  async startLocationUpdatesAsync(taskName, options = {}) {
    try {
      // Start location tracking
      await this.startLocationTracking(options);
      return { success: true };
    } catch (error) {
      errorLogger.logError('Failed to start location updates', error);
      throw error;
    }
  }

  async stopLocationUpdatesAsync(taskName) {
    try {
      await this.stopLocationTracking();
      return { success: true };
    } catch (error) {
      errorLogger.logError('Failed to stop location updates', error);
      throw error;
    }
  }

  async getCurrentLocation() {
    return this.getCurrentPositionAsync();
  }

  async requestLocationPermissions() {
    const foreground = await this.requestForegroundPermissionsAsync();
    const background = await this.requestBackgroundPermissionsAsync();
    
    return {
      foreground: foreground.status,
      background: background.status,
      all: foreground.status === 'granted' && background.status === 'granted'
    };
  }

  async checkLocationServicesAvailability() {
    try {
      await this.getCurrentPositionAsync();
      return { available: true, message: 'Location services available' };
    } catch (error) {
      return { available: false, message: error.message };
    }
  }
}

/**
 * Handles health data synchronization from Health Connect
 */
class HealthModule {
  constructor(parent) {
    this.parent = parent;
    this.isSyncing = false;
    this.healthConnect = HealthConnect;
    this.grantedPermissions = new Set();
    this.recordTypes = {
      STEPS: 'Steps',
      HEART_RATE: 'HeartRate',
      DISTANCE: 'Distance',
      ACTIVE_CALORIES: 'ActiveCaloriesBurned',
      TOTAL_CALORIES: 'TotalCaloriesBurned',
      EXERCISE: 'ExerciseSession',
      SLEEP: 'SleepSession',
      WEIGHT: 'Weight',
      HEIGHT: 'Height',
      BODY_FAT: 'BodyFat'
    };
  }

  async startHealthSync(options = {}) {
    if (this.isSyncing) return;
    
    try {
      this.isSyncing = true;
      
      // Initialize Health Connect if available
      if (Platform.OS === 'android' && this.healthConnect) {
        await this.initializeHealthConnect();
      }
      
    } catch (error) {
      errorLogger.logError('Failed to start health sync', error);
      throw error;
    }
  }

  async stopHealthSync() {
    this.isSyncing = false;
  }

  async initializeHealthConnect() {
    try {
      // Check if Health Connect is available
      const isAvailable = await this.isHealthConnectAvailable();
      if (!isAvailable) {
        throw new Error('Health Connect is not available on this device');
      }

      // Request permissions
      await this.requestHealthPermissions();
      
    } catch (error) {
      errorLogger.logError('Health Connect initialization failed', error);
      throw error;
    }
  }

  async isHealthConnectAvailable() {
    try {
      return await this.healthConnect.isAvailable();
    } catch (error) {
      return false;
    }
  }

  async requestHealthPermissions(dataTypes = ['steps', 'heart_rate', 'exercise']) {
    const permissions = [];
    
    dataTypes.forEach(type => {
      switch (type) {
        case 'steps':
          permissions.push({ accessType: 'read', recordType: 'Steps' });
          break;
        case 'heart_rate':
          permissions.push({ accessType: 'read', recordType: 'HeartRate' });
          break;
        case 'exercise':
          permissions.push({ accessType: 'read', recordType: 'ExerciseSession' });
          break;
        case 'sleep':
          permissions.push({ accessType: 'read', recordType: 'SleepSession' });
          break;
      }
    });

    try {
      return await this.healthConnect.requestPermissions(permissions);
    } catch (error) {
      errorLogger.logError('Health permissions request failed', error);
      throw error;
    }
  }

  /**
   * Sync health data from Health Connect
   */
  async syncHealthData(date) {
    const start = performanceService?.startTracking?.('health.syncHealthData');
    
    try {
      if (Platform.OS !== 'android' || !this.healthConnect) {
        // Return aggregated data from activities for non-Android platforms
        return this.aggregateHealthFromActivities(date);
      }

      const startOfDay = new Date(date);
      startOfDay.setHours(0, 0, 0, 0);
      const endOfDay = new Date(date);
      endOfDay.setHours(23, 59, 59, 999);

      // Collect data from Health Connect
      const [steps, heartRate, exercise, sleep] = await Promise.all([
        this.getSteps(startOfDay, endOfDay),
        this.getHeartRate(startOfDay, endOfDay),
        this.getExercise(startOfDay, endOfDay),
        this.getSleep(startOfDay, endOfDay)
      ]);

      const healthData = {
        date: date,
        steps: steps,
        heart_rate: heartRate,
        exercise: exercise,
        sleep: sleep,
        synced_at: Date.now(),
        source: 'HealthConnect'
      };

      performanceService?.endTracking?.(start);
      return healthData;
      
    } catch (error) {
      performanceService?.endTracking?.(start, error);
      errorLogger.logError('Health data sync failed', error);
      
      // Fallback to aggregated activity data
      return this.aggregateHealthFromActivities(date);
    }
  }

  async getSteps(startDate, endDate) {
    try {
      const records = await this.healthConnect.getSteps(startDate.getTime(), endDate.getTime());
      return this.aggregateSteps(records);
    } catch (error) {
      return 0;
    }
  }

  async getHeartRate(startDate, endDate) {
    try {
      const records = await this.healthConnect.getHeartRate(startDate.getTime(), endDate.getTime());
      return this.aggregateHeartRate(records);
    } catch (error) {
      return { average: 0, min: 0, max: 0, count: 0 };
    }
  }

  async getExercise(startDate, endDate) {
    try {
      const records = await this.healthConnect.getExercise(startDate.getTime(), endDate.getTime());
      return this.aggregateExercise(records);
    } catch (error) {
      return [];
    }
  }

  async getSleep(startDate, endDate) {
    try {
      const records = await this.healthConnect.getSleep(startDate.getTime(), endDate.getTime());
      return this.aggregateSleep(records);
    } catch (error) {
      return { totalMinutes: 0, sessions: [] };
    }
  }

  aggregateSteps(records) {
    return records.reduce((total, record) => total + (record.count || 0), 0);
  }

  aggregateHeartRate(records) {
    if (!records.length) return { average: 0, min: 0, max: 0, count: 0 };
    
    const values = records.map(r => r.bpm).filter(v => v > 0);
    if (!values.length) return { average: 0, min: 0, max: 0, count: 0 };
    
    return {
      average: Math.round(values.reduce((a, b) => a + b, 0) / values.length),
      min: Math.min(...values),
      max: Math.max(...values),
      count: values.length
    };
  }

  aggregateExercise(records) {
    return records.map(record => ({
      type: record.exerciseType || 'unknown',
      start_time: record.startTime,
      end_time: record.endTime,
      duration: record.endTime - record.startTime,
      calories: record.energyBurned || 0,
      distance: record.distance || 0
    }));
  }

  aggregateSleep(records) {
    const sessions = records.map(record => ({
      start_time: record.startTime,
      end_time: record.endTime,
      duration: record.endTime - record.startTime,
      stage: record.stage || 'unknown'
    }));
    
    const totalMinutes = sessions.reduce((total, session) => 
      total + Math.floor(session.duration / 60000), 0
    );
    
    return {
      totalMinutes,
      sessions
    };
  }

  aggregateHealthFromActivities(date) {
    // Fallback: aggregate health data from activities
    return {
      date: date,
      steps: 0, // Will be calculated from activity data
      heart_rate: { average: 0, min: 0, max: 0, count: 0 },
      exercise: [],
      sleep: { totalMinutes: 0, sessions: [] },
      synced_at: Date.now(),
      source: 'ActivityAggregation'
    };
  }

  // Core health methods
  async getHealthStats(date) {
    return this.syncHealthData(date);
  }

  async getHealthDataForDateRange(startDate, endDate) {
    const results = [];
    const currentDate = new Date(startDate);
    
    while (currentDate <= endDate) {
      const healthData = await this.getHealthStats(currentDate);
      if (healthData) {
        results.push(healthData);
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    return results;
  }

  async batchSyncHealthData(dates) {
    const results = [];
    
    for (const date of dates) {
      try {
        const healthData = await this.syncHealthData(date);
        results.push({ success: true, data: healthData });
      } catch (error) {
        results.push({ success: false, error: error.message, date });
      }
    }
    
    return results;
  }

  // Missing Health Connect methods
  async openHealthConnectInPlayStore() {
    try {
      if (!this.isHealthConnectAvailable()) {
        throw new Error('Health Connect not available');
      }
      
      const result = await this.healthConnect.openHealthConnectInPlayStore();
      errorLogger.info('Opened Health Connect in Play Store');
      return result;
    } catch (error) {
      errorLogger.logError('Failed to open Health Connect in Play Store', error);
      throw error;
    }
  }

  async openHealthConnectSettings() {
    try {
      if (!await this.isHealthConnectAvailable()) {
        throw new Error('Health Connect not available');
      }
      
      const result = await this.healthConnect.openHealthConnectSettings();
      errorLogger.info('Opened Health Connect settings');
      return result;
    } catch (error) {
      errorLogger.logError('Failed to open Health Connect settings', error);
      throw error;
    }
  }

  async openHealthConnectPermissions() {
    try {
      if (!await this.isHealthConnectAvailable()) {
        throw new Error('Health Connect not available');
      }
      
      const result = await this.healthConnect.openHealthConnectPermissions();
      errorLogger.info('Opened Health Connect permissions screen');
      return result;
    } catch (error) {
      errorLogger.logError('Failed to open Health Connect permissions', error);
      throw error;
    }
  }

  async isSamsungHealthConnected() {
    try {
      // Check if Samsung Health is connected to Health Connect
      // This is a simplified check - Samsung Health should be visible in Health Connect app permissions
      const hasAnyPermissions = this.grantedPermissions?.size > 0;
      
      if (!hasAnyPermissions) {
        errorLogger.warn('No Health Connect permissions granted - Samsung Health may not be connected');
        return false;
      }
      
      errorLogger.info('Samsung Health appears to be connected to Health Connect');
      return true;
    } catch (error) {
      errorLogger.logError('Failed to check Samsung Health connection', error);
      return false;
    }
  }

  async checkPermissions(permissions) {
    try {
      if (!await this.isHealthConnectAvailable()) {
        throw new Error('Health Connect not available');
      }

      const result = await this.healthConnect.checkPermissions(permissions);
      
      // Update local granted permissions
      if (this.grantedPermissions) {
        this.grantedPermissions.clear();
        if (result.granted && Array.isArray(result.granted)) {
          result.granted.forEach(permission => {
            this.grantedPermissions.add(permission.recordType);
          });
        }
      }

      return result;
    } catch (error) {
      errorLogger.logError('Failed to check permissions', error);
      throw error;
    }
  }

  async importHealthData(startDate, endDate, dataTypes = ['steps', 'heart_rate', 'exercise', 'sleep']) {
    try {
      errorLogger.info(`Starting health data import for ${dataTypes.join(', ')}`);
      
      // Step 1: Check if Health Connect is available
      if (!await this.isHealthConnectAvailable()) {
        return {
          success: false,
          imported: 0,
          errors: ['Health Connect is niet beschikbaar op dit apparaat. Installeer Health Connect via Google Play Store.']
        };
      }

      // Step 2: Check current permissions
      const permissionRequests = dataTypes.map(dataType => this.mapDataTypeToPermission(dataType));
      const permissionsResult = await this.checkPermissions(permissionRequests);

      errorLogger.info(`Current permissions: ${permissionsResult.granted.length} granted, ${permissionsResult.denied.length} denied`);

      // Step 3: Request missing permissions if needed
      if (permissionsResult.denied.length > 0) {
        errorLogger.info(`Requesting permissions for: ${permissionsResult.denied.map(p => p.recordType).join(', ')}`);
        
        const requestResult = await this.requestPermissions(dataTypes);
        
        if (!requestResult.success || requestResult.denied.length > 0) {
          const deniedTypes = requestResult.denied.map(p => p.recordType).join(', ');
          return {
            success: false,
            imported: 0,
            errors: [`Geen toestemming voor: ${deniedTypes}. Ga naar Instellingen > Health Connect > App-machtigingen > Samsung Health om toestemming te verlenen.`]
          };
        }
      }

      // Step 4: Check if Samsung Health is connected to Health Connect
      const samsungHealthConnected = await this.isSamsungHealthConnected();
      if (!samsungHealthConnected) {
        return {
          success: false,
          imported: 0,
          errors: ['Samsung Health is niet gekoppeld aan Health Connect. Open Samsung Health > Instellingen > Health Connect en schakel data synchronisatie in.']
        };
      }
      
      let totalImported = 0;
      const errors = [];

      // Step 5: Import each data type
      for (const dataType of dataTypes) {
        try {
          errorLogger.info(`Importing ${dataType} data...`);
          
          let records = [];
          
          switch (dataType.toLowerCase()) {
            case 'steps':
              records = await this.getSteps(startDate, endDate);
              break;
            case 'heart_rate':
            case 'heartrate':
              records = await this.getHeartRate(startDate, endDate);
              break;
            case 'exercise':
            case 'workout':
              records = await this.getExercise(startDate, endDate);
              break;
            case 'sleep':
              records = await this.getSleep(startDate, endDate);
              break;
            case 'distance':
              records = await this.getDistance(startDate, endDate);
              break;
            case 'calories':
            case 'active_calories':
              records = await this.getCalories(startDate, endDate, 'active');
              break;
            case 'total_calories':
              records = await this.getCalories(startDate, endDate, 'total');
              break;
            default:
              throw new Error(`Unknown data type: ${dataType}`);
          }

          // Check if we actually got data
          if (records.length === 0) {
            errorLogger.warn(`No ${dataType} data found in Health Connect for the specified period`);
            continue;
          }

          // Save to database
          const imported = await this.saveRecordsToDatabase(records, dataType);
          totalImported += imported;
          errorLogger.info(`Successfully imported ${imported} ${dataType} records`);
          
        } catch (error) {
          errorLogger.logError(`Failed to import ${dataType}`, error);
          errors.push(`${dataType}: ${error.message}`);
        }
      }

      // Step 6: Final result
      const result = {
        success: errors.length === 0 && totalImported > 0,
        imported: totalImported,
        errors: errors
      };

      if (totalImported === 0 && errors.length === 0) {
        result.errors = ['Geen health data gevonden in Health Connect voor de opgegeven periode. Controleer of Samsung Health data heeft gesynchroniseerd.'];
        result.success = false;
      }

      errorLogger.info(`Health data import completed: ${totalImported} records imported, ${errors.length} errors`);
      
      return result;
    } catch (error) {
      errorLogger.logError('Health data import failed', error);
      return {
        success: false,
        imported: 0,
        errors: [error.message]
      };
    }
  }

  hasPermission(recordType) {
    return this.grantedPermissions?.has(recordType) || false;
  }

  mapDataTypeToPermission(dataType) {
    switch (dataType.toLowerCase()) {
      case 'steps':
        return { accessType: 'read', recordType: 'Steps' };
      case 'heart_rate':
      case 'heartrate':
        return { accessType: 'read', recordType: 'HeartRate' };
      case 'distance':
        return { accessType: 'read', recordType: 'Distance' };
      case 'calories':
      case 'active_calories':
        return { accessType: 'read', recordType: 'ActiveCaloriesBurned' };
      case 'total_calories':
        return { accessType: 'read', recordType: 'TotalCaloriesBurned' };
      case 'exercise':
      case 'workout':
        return { accessType: 'read', recordType: 'ExerciseSession' };
      case 'sleep':
        return { accessType: 'read', recordType: 'SleepSession' };
      case 'weight':
        return { accessType: 'read', recordType: 'Weight' };
      case 'height':
        return { accessType: 'read', recordType: 'Height' };
      case 'body_fat':
        return { accessType: 'read', recordType: 'BodyFat' };
      default:
        throw new Error(`Unknown data type: ${dataType}`);
    }
  }

  // Private helper methods
  formatStepsRecords(records) {
    if (!Array.isArray(records)) return [];
    
    return records.map(record => ({
      id: record.recordId || record.id,
      startTime: new Date(record.startTime).getTime(),
      endTime: new Date(record.endTime).getTime(),
      steps: parseInt(record.count || record.steps || 0),
      source: 'health_connect',
      metadata: {
        device: record.device || null,
        accuracy: record.accuracy || null
      }
    })).filter(record => record.steps > 0);
  }

  formatHeartRateRecords(records) {
    if (!Array.isArray(records)) return [];
    
    return records.map(record => ({
      id: record.recordId || record.id,
      timestamp: new Date(record.time || record.timestamp).getTime(),
      bpm: parseInt(record.beatsPerMinute || record.bpm || 0),
      source: 'health_connect',
      metadata: {
        device: record.device || null
      }
    })).filter(record => record.bpm > 0 && record.bpm < 300);
  }

  formatExerciseRecords(records) {
    if (!Array.isArray(records)) return [];
    
    return records.map(record => ({
      id: record.recordId || record.id,
      startTime: new Date(record.startTime).getTime(),
      endTime: new Date(record.endTime).getTime(),
      duration: Math.round((new Date(record.endTime) - new Date(record.startTime)) / 1000 / 60),
      exerciseType: record.exerciseType || 'unknown',
      title: record.title || null,
      calories: parseInt(record.totalActiveCalories || 0),
      distance: parseFloat(record.totalDistance || 0),
      source: 'health_connect',
      metadata: {
        notes: record.notes || null
      }
    }));
  }

  formatSleepRecords(records) {
    if (!Array.isArray(records)) return [];
    
    return records.map(record => ({
      id: record.recordId || record.id,
      startTime: new Date(record.startTime).getTime(),
      endTime: new Date(record.endTime).getTime(),
      duration: Math.round((new Date(record.endTime) - new Date(record.startTime)) / 1000 / 60),
      source: 'health_connect',
      metadata: {
        stages: record.stages || [],
        notes: record.notes || null
      }
    }));
  }

  formatDistanceRecords(records) {
    if (!Array.isArray(records)) return [];
    
    return records.map(record => ({
      id: record.recordId || record.id,
      startTime: new Date(record.startTime).getTime(),
      endTime: new Date(record.endTime).getTime(),
      distance: parseFloat(record.distance || 0),
      unit: 'meters',
      source: 'health_connect',
      metadata: {
        device: record.device || null
      }
    })).filter(record => record.distance > 0);
  }

  formatCaloriesRecords(records, type) {
    if (!Array.isArray(records)) return [];
    
    return records.map(record => ({
      id: record.recordId || record.id,
      startTime: new Date(record.startTime).getTime(),
      endTime: new Date(record.endTime).getTime(),
      calories: parseInt(record.energy || record.calories || 0),
      type: type,
      unit: 'kcal',
      source: 'health_connect',
      metadata: {
        device: record.device || null
      }
    })).filter(record => record.calories > 0);
  }

  async saveRecordsToDatabase(records, dataType) {
    let imported = 0;
    
    for (const record of records) {
      try {
        // Map data to correct database columns based on type
        const activityData = {
          type: dataType,
          startTime: record.startTime || record.timestamp,
          endTime: record.endTime || record.timestamp,
          duration: record.duration || null,
          source: 'health_connect',
          metadata: record.metadata || {}
        };

        // Set the appropriate column based on data type
        switch (dataType.toLowerCase()) {
          case 'steps':
            activityData.details = { steps: record.steps };
            break;
          case 'heart_rate':
            activityData.heart_rate_avg = record.bpm;
            break;
          case 'exercise':
          case 'workout':
            activityData.sport_type = record.exerciseType || 'unknown';
            activityData.calories = record.calories || 0;
            activityData.distance = record.distance || 0;
            break;
          case 'sleep':
            activityData.duration = record.duration;
            break;
          case 'distance':
            activityData.distance = record.distance || 0;
            break;
          case 'calories':
          case 'active_calories':
          case 'total_calories':
            activityData.calories = record.calories || 0;
            break;
          default:
            activityData.details = record;
        }

        await database.saveActivity(activityData);
        imported++;
      } catch (error) {
        errorLogger.logError(`Error saving ${dataType} record`, error);
      }
    }
    
    return imported;
  }

  async queryHealthData(type, startTime, endTime) {
    try {
      let query, params;
      
      switch (type.toLowerCase()) {
        case 'steps':
          // Steps are stored in details JSON, need to extract them
          query = `SELECT COUNT(*) as total FROM activities WHERE type = ? AND start_time >= ? AND start_time <= ? AND source = ?`;
          params = [type, startTime, endTime, 'health_connect'];
          const result = await database.safeGetAllAsync(query, params);
          // For steps, we return the count of step records (simplified for now)
          return result[0]?.total * 8000 || 0; // Estimate 8000 steps per record
          
        case 'calories':
        case 'active_calories':
        case 'total_calories':
          query = 'SELECT COALESCE(SUM(calories), 0) as total FROM activities WHERE type IN (?, ?, ?) AND start_time >= ? AND start_time <= ? AND source = ?';
          params = ['calories', 'active_calories', 'total_calories', startTime, endTime, 'health_connect'];
          break;
          
        case 'distance':
          query = 'SELECT COALESCE(SUM(distance), 0) as total FROM activities WHERE type = ? AND start_time >= ? AND start_time <= ? AND source = ?';
          params = [type, startTime, endTime, 'health_connect'];
          break;
          
        case 'exercise':
        case 'workout':
          query = 'SELECT COUNT(*) as total FROM activities WHERE type IN (?, ?) AND start_time >= ? AND start_time <= ? AND source = ?';
          params = ['exercise', 'workout', startTime, endTime, 'health_connect'];
          break;
          
        default:
          // Default to count for unknown types
          query = 'SELECT COUNT(*) as total FROM activities WHERE type = ? AND start_time >= ? AND start_time <= ? AND source = ?';
          params = [type, startTime, endTime, 'health_connect'];
      }
      
      const result = await database.safeGetAllAsync(query, params);
      return result[0]?.total || 0;
    } catch (error) {
      errorLogger.logError('Error querying health data', error);
      return 0;
    }
  }

  async queryRecentWorkouts(startTime, endTime) {
    try {
      const result = await database.safeGetAllAsync(
        'SELECT COUNT(*) as count, COALESCE(SUM(duration), 0) as total_duration FROM activities WHERE type = ? AND start_time >= ? AND start_time <= ? AND source = ?',
        ['exercise', startTime, endTime, 'health_connect']
      );
      return {
        count: result[0]?.count || 0,
        duration: result[0]?.total_duration || 0
      };
    } catch (error) {
      errorLogger.logError('Error querying workout data', error);
      return { count: 0, duration: 0 };
    }
  }
}

// ============================================
// EXPORT SINGLETON INSTANCE
// ============================================

/**
 * Create and export singleton instance
 * This ensures single shared state across the application
 */
const activityTrackingService = new ActivityTrackingService();

// Initialize immediately
activityTrackingService.initializePlatform();

export default activityTrackingService;