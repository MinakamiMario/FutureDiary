// src/services/healthConnectService.js
// Modern Health Connect API implementation voor Android Health data

import BaseService from './BaseService';
import databaseService from './databaseSelector';
import { Platform } from 'react-native';

// Health Connect record types mapping
const HEALTH_RECORDS = {
  STEPS: 'Steps',
  HEART_RATE: 'HeartRate', 
  DISTANCE: 'Distance',
  CALORIES: 'TotalCaloriesBurned',
  EXERCISE: 'ExerciseSession',
  SLEEP: 'SleepSession',
  WEIGHT: 'Weight',
  HEIGHT: 'Height',
  ACTIVE_CALORIES: 'ActiveCaloriesBurned'
};

// Demo data for development/testing
const DEMO_HEALTH_DATA = {
  steps: 8500 + Math.floor(Math.random() * 3000),
  heartRate: 72 + Math.floor(Math.random() * 20),
  calories: 2200 + Math.floor(Math.random() * 800),
  distance: 6.2 + Math.random() * 2,
  activeMinutes: 45 + Math.floor(Math.random() * 30),
  sleep: 7.5 + Math.random() * 2,
  weight: 70 + Math.random() * 20,
  isTracking: true
};

class HealthConnectService extends BaseService {
  constructor() {
    super('HealthConnectService');
    this.isHealthConnectAvailable = false;
    this.permissionsGranted = new Set();
    this.lastSyncTime = null;
  }

  async onInitialize() {
    await this.info('Health Connect service initialiseren...');
    
    try {
      if (Platform.OS !== 'android') {
        await this.warn('Health Connect alleen beschikbaar op Android');
        return;
      }

      // Check Health Connect availability
      await this.checkHealthConnectAvailability();
      
      if (this.isHealthConnectAvailable) {
        // Request permissions voor belangrijkste data types
        await this.requestHealthConnectPermissions();
        await this.info(`Health Connect geÃ¯nitialiseerd - Permissions: ${this.permissionsGranted.size}`);
      } else {
        await this.warn('Health Connect niet beschikbaar - demo mode actief');
      }
      
    } catch (error) {
      await this.error('Health Connect initialization failed', error);
      this.isHealthConnectAvailable = false;
    }
  }

  // Check if Health Connect is available on device
  async checkHealthConnectAvailability() {
    try {
      // For now, simulate Health Connect availability on Android
      if (Platform.OS === 'android') {
        this.isHealthConnectAvailable = true;
        await this.info('Health Connect demo mode - simulated availability');
      } else {
        this.isHealthConnectAvailable = false;
        await this.warn('Health Connect alleen beschikbaar op Android');
      }
      
    } catch (error) {
      await this.error('Failed to check Health Connect availability', error);
      this.isHealthConnectAvailable = false;
    }
  }

  // Request permissions for health data types
  async requestHealthConnectPermissions() {
    try {
      // Simulate permission request for demo
      const requestedPermissions = [
        'Steps', 'HeartRate', 'Distance', 'TotalCaloriesBurned', 
        'ActiveCaloriesBurned', 'ExerciseSession', 'SleepSession', 'Weight'
      ];

      // Store granted permissions (simulate all granted for demo)
      this.permissionsGranted.clear();
      requestedPermissions.forEach(permission => {
        this.permissionsGranted.add(permission);
      });

      await this.info(`Health Connect permissions granted (demo): ${requestedPermissions.length}`);
      
      return {
        success: true,
        granted: requestedPermissions,
        total: requestedPermissions.length
      };
      
    } catch (error) {
      await this.error('Failed to request Health Connect permissions', error);
      return {
        success: false,
        granted: [],
        error: error.message
      };
    }
  }

  // Check if demo mode should be used
  isDemoMode() {
    // Use demo mode for now during development
    // TODO: Enable real Health Connect after testing
    return true;
    
    // Future implementation:
    // return !this.isHealthConnectAvailable || 
    //        __DEV__ || 
    //        this.permissionsGranted.size === 0;
  }

  // Get health data availability status
  async getHealthDataAvailability() {
    return {
      platform: Platform.OS,
      healthConnectAvailable: this.isHealthConnectAvailable,
      permissionsGranted: Array.from(this.permissionsGranted),
      hasHealthAccess: this.isHealthConnectAvailable && this.permissionsGranted.size > 0,
      supportedDataTypes: this.getSupportedDataTypes(),
      demoMode: this.isDemoMode(),
      lastSync: this.lastSyncTime
    };
  }

  // Get supported data types
  getSupportedDataTypes() {
    if (this.isDemoMode()) {
      return ['steps', 'heart_rate', 'calories', 'distance', 'sleep', 'exercise', 'weight'];
    }
    
    return Array.from(this.permissionsGranted).map(permission => 
      permission.toLowerCase().replace(/([A-Z])/g, '_$1').toLowerCase()
    );
  }

  // Import health data from Health Connect
  async importHealthData(startDate, endDate, dataTypes = ['all']) {
    if (this.isDemoMode()) {
      return await this.importDemoHealthData(startDate, endDate, dataTypes);
    }

    try {
      let importResults = {
        success: true,
        imported: 0,
        details: {},
        errors: []
      };

      await this.info(`Importing Health Connect data from ${new Date(startDate).toLocaleDateString()} to ${new Date(endDate).toLocaleDateString()}`);

      // Import each requested data type
      if (dataTypes.includes('all') || dataTypes.includes('steps')) {
        if (this.permissionsGranted.has(HEALTH_RECORDS.STEPS)) {
          const stepsResult = await this.importStepsData(startDate, endDate);
          importResults.imported += stepsResult.imported;
          importResults.details.steps = stepsResult;
        }
      }

      if (dataTypes.includes('all') || dataTypes.includes('heart_rate')) {
        if (this.permissionsGranted.has(HEALTH_RECORDS.HEART_RATE)) {
          const heartRateResult = await this.importHeartRateData(startDate, endDate);
          importResults.imported += heartRateResult.imported;
          importResults.details.heart_rate = heartRateResult;
        }
      }

      if (dataTypes.includes('all') || dataTypes.includes('exercise')) {
        if (this.permissionsGranted.has(HEALTH_RECORDS.EXERCISE)) {
          const exerciseResult = await this.importExerciseData(startDate, endDate);
          importResults.imported += exerciseResult.imported;
          importResults.details.exercise = exerciseResult;
        }
      }

      if (dataTypes.includes('all') || dataTypes.includes('sleep')) {
        if (this.permissionsGranted.has(HEALTH_RECORDS.SLEEP)) {
          const sleepResult = await this.importSleepData(startDate, endDate);
          importResults.imported += sleepResult.imported;
          importResults.details.sleep = sleepResult;
        }
      }

      this.lastSyncTime = Date.now();
      await this.info(`Health Connect import completed: ${importResults.imported} items`);
      
      return importResults;

    } catch (error) {
      await this.error('Health Connect import failed', error);
      return {
        success: false,
        message: error.message,
        imported: 0
      };
    }
  }

  // Import steps data from Health Connect
  async importStepsData(startDate, endDate) {
    try {
      // Generate demo steps data for the date range
      const demoSteps = this.generateDemoSteps(startDate, endDate);
      
      let imported = 0;
      for (const dayData of demoSteps) {
        try {
          await databaseService.saveActivity({
            type: 'steps',
            startTime: dayData.timestamp,
            endTime: dayData.timestamp + (24 * 60 * 60 * 1000),
            value: dayData.steps,
            source: 'health_connect_demo',
            metadata: {
              demo_mode: true,
              generated_at: Date.now()
            }
          });
          imported++;
        } catch (error) {
          await this.error('Error saving demo steps record', error);
        }
      }

      return { imported, total: demoSteps.length };
    } catch (error) {
      await this.error('Failed to import steps data', error);
      return { imported: 0, total: 0, error: error.message };
    }
  }

  // Import heart rate data from Health Connect
  async importHeartRateData(startDate, endDate) {
    try {
      const heartRateRecords = await HealthConnectModule.readHeartRateRecords({
        startTime: new Date(startDate).toISOString(),
        endTime: new Date(endDate).toISOString()
      });

      let imported = 0;
      for (const record of heartRateRecords) {
        try {
          await databaseService.saveActivity({
            type: 'heart_rate',
            startTime: new Date(record.time).getTime(),
            endTime: new Date(record.time).getTime(),
            value: record.beatsPerMinute,
            source: 'health_connect',
            metadata: {
              record_id: record.recordId,
              device: record.device || null
            }
          });
          imported++;
        } catch (error) {
          await this.error('Error saving heart rate record', error);
        }
      }

      return { imported, total: heartRateRecords.length };
    } catch (error) {
      await this.error('Failed to import heart rate data', error);
      return { imported: 0, total: 0, error: error.message };
    }
  }

  // Import exercise data from Health Connect  
  async importExerciseData(startDate, endDate) {
    try {
      const exerciseRecords = await HealthConnectModule.readExerciseRecords({
        startTime: new Date(startDate).toISOString(),
        endTime: new Date(endDate).toISOString()
      });

      let imported = 0;
      for (const record of exerciseRecords) {
        try {
          const duration = Math.round((new Date(record.endTime) - new Date(record.startTime)) / 1000 / 60);
          
          await databaseService.saveActivity({
            type: 'workout',
            sport_type: this.mapExerciseType(record.exerciseType),
            startTime: new Date(record.startTime).getTime(),
            endTime: new Date(record.endTime).getTime(),
            duration: duration,
            calories: record.totalActiveCalories || 0,
            distance: record.totalDistance || 0,
            source: 'health_connect',
            metadata: {
              record_id: record.recordId,
              exercise_type: record.exerciseType,
              title: record.title || null,
              notes: record.notes || null
            }
          });
          imported++;
        } catch (error) {
          await this.error('Error saving exercise record', error);
        }
      }

      return { imported, total: exerciseRecords.length };
    } catch (error) {
      await this.error('Failed to import exercise data', error);
      return { imported: 0, total: 0, error: error.message };
    }
  }

  // Import sleep data from Health Connect
  async importSleepData(startDate, endDate) {
    try {
      const sleepRecords = await HealthConnectModule.readSleepRecords({
        startTime: new Date(startDate).toISOString(),
        endTime: new Date(endDate).toISOString()
      });

      let imported = 0;
      for (const record of sleepRecords) {
        try {
          const duration = Math.round((new Date(record.endTime) - new Date(record.startTime)) / 1000 / 60);
          
          await databaseService.saveActivity({
            type: 'sleep',
            startTime: new Date(record.startTime).getTime(),
            endTime: new Date(record.endTime).getTime(),
            duration: duration,
            source: 'health_connect',
            metadata: {
              record_id: record.recordId,
              sleep_stages: record.stages || [],
              notes: record.notes || null
            }
          });
          imported++;
        } catch (error) {
          await this.error('Error saving sleep record', error);
        }
      }

      return { imported, total: sleepRecords.length };
    } catch (error) {
      await this.error('Failed to import sleep data', error);
      return { imported: 0, total: 0, error: error.message };
    }
  }

  // Map Health Connect exercise types to our sport types
  mapExerciseType(exerciseType) {
    const mapping = {
      'RUNNING': 'running',
      'WALKING': 'walking', 
      'CYCLING': 'cycling',
      'SWIMMING': 'swimming',
      'YOGA': 'yoga',
      'TENNIS': 'tennis',
      'FOOTBALL': 'football',
      'BASKETBALL': 'basketball',
      'HIKING': 'hiking',
      'SKIING': 'skiing',
      'ROWING': 'rowing',
      'STRENGTH_TRAINING': 'gym',
      'WEIGHT_LIFTING': 'gym',
      'GOLF': 'golf',
      'CLIMBING': 'climbing'
    };
    
    return mapping[exerciseType] || exerciseType.toLowerCase();
  }

  // Get current health statistics
  async getCurrentStats() {
    try {
      const now = Date.now();
      const yesterday = now - (24 * 60 * 60 * 1000);
      const weekAgo = now - (7 * 24 * 60 * 60 * 1000);

      if (this.isDemoMode()) {
        return this._getDemoStats();
      }

      // Query database for real stats
      const [dailySteps, weeklySteps, recentWorkouts] = await Promise.all([
        this._queryHealthData('steps', yesterday, now),
        this._queryHealthData('steps', weekAgo, now), 
        this._queryRecentWorkouts(weekAgo, now)
      ]);

      return {
        daily: {
          steps: dailySteps || 0,
          calories: Math.round((dailySteps || 0) * 0.04), // Rough estimate
          distance: Math.round((dailySteps || 0) * 0.0008 * 100) / 100 // Rough estimate
        },
        weekly: {
          steps: weeklySteps || 0,
          calories: Math.round((weeklySteps || 0) * 0.04),
          distance: Math.round((weeklySteps || 0) * 0.0008 * 100) / 100,
          workouts: recentWorkouts.count || 0,
          workout_duration: recentWorkouts.duration || 0
        },
        platform: Platform.OS,
        last_updated: now,
        demo_mode: false,
        source: 'health_connect'
      };
    } catch (error) {
      await this.error('Error getting current stats', error);
      return this._getEmptyStats();
    }
  }

  // Helper method to query health data
  async _queryHealthData(type, startTime, endTime) {
    try {
      const result = await databaseService.safeGetAllAsync(
        'SELECT COALESCE(SUM(value), 0) as total FROM activities WHERE type = ? AND start_time >= ? AND start_time <= ? AND source = ?',
        [type, startTime, endTime, 'health_connect']
      );
      return result[0]?.total || 0;
    } catch (error) {
      await this.error('Error querying health data', error);
      return 0;
    }
  }

  // Helper method to query recent workouts
  async _queryRecentWorkouts(startTime, endTime) {
    try {
      const result = await databaseService.safeGetAllAsync(
        'SELECT COUNT(*) as count, COALESCE(SUM(duration), 0) as total_duration FROM activities WHERE type = ? AND start_time >= ? AND start_time <= ? AND source = ?',
        ['workout', startTime, endTime, 'health_connect']
      );
      return {
        count: result[0]?.count || 0,
        duration: result[0]?.total_duration || 0
      };
    } catch (error) {
      await this.error('Error querying workout data', error);
      return { count: 0, duration: 0 };
    }
  }

  // Get demo stats for development
  _getDemoStats() {
    return {
      daily: {
        steps: DEMO_HEALTH_DATA.steps,
        calories: Math.floor(DEMO_HEALTH_DATA.calories * 0.3),
        distance: DEMO_HEALTH_DATA.distance
      },
      weekly: {
        steps: DEMO_HEALTH_DATA.steps * 7,
        calories: DEMO_HEALTH_DATA.calories,
        distance: DEMO_HEALTH_DATA.distance * 7,
        workouts: 3 + Math.floor(Math.random() * 4),
        workout_duration: DEMO_HEALTH_DATA.activeMinutes * 7
      },
      platform: Platform.OS,
      last_updated: Date.now(),
      demo_mode: true,
      source: 'demo'
    };
  }

  // Get empty stats structure
  _getEmptyStats() {
    return {
      daily: { steps: 0, calories: 0, distance: 0 },
      weekly: { steps: 0, calories: 0, distance: 0, workouts: 0, workout_duration: 0 },
      platform: Platform.OS,
      last_updated: Date.now(),
      demo_mode: false,
      source: 'none'
    };
  }

  // Import demo health data for testing
  async importDemoHealthData(startDate, endDate, dataTypes = ['all']) {
    try {
      await this.info('Generating demo Health Connect data...');
      
      const daysToGenerate = Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000));
      let imported = 0;

      // Generate demo steps
      if (dataTypes.includes('all') || dataTypes.includes('steps')) {
        const stepsData = this.generateDemoSteps(startDate, endDate);
        for (const dayData of stepsData) {
          await databaseService.saveActivity({
            type: 'steps',
            startTime: dayData.timestamp,
            endTime: dayData.timestamp + (24 * 60 * 60 * 1000),
            value: dayData.steps,
            source: 'health_connect_demo',
            metadata: { demo_mode: true }
          });
          imported++;
        }
      }

      // Generate demo workouts
      if (dataTypes.includes('all') || dataTypes.includes('exercise')) {
        const workoutsData = this.generateDemoWorkouts(startDate, endDate);
        for (const workout of workoutsData) {
          await databaseService.saveActivity({
            type: 'workout',
            sport_type: workout.sport_type,
            startTime: workout.start_time,
            endTime: workout.end_time,
            duration: workout.duration,
            calories: workout.calories,
            distance: workout.distance,
            source: 'health_connect_demo',
            metadata: { demo_mode: true }
          });
          imported++;
        }
      }

      return {
        success: true,
        imported: imported,
        message: `Demo Health Connect data generated for ${daysToGenerate} days`,
        source: 'health_connect_demo'
      };

    } catch (error) {
      await this.error('Demo Health Connect data generation failed', error);
      return {
        success: false,
        message: 'Demo data generation failed',
        imported: 0
      };
    }
  }

  // Generate demo steps data
  generateDemoSteps(startDate, endDate) {
    const steps = [];
    const oneDay = 24 * 60 * 60 * 1000;
    
    for (let timestamp = startDate; timestamp <= endDate; timestamp += oneDay) {
      const dayOfWeek = new Date(timestamp).getDay();
      const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
      
      const baseSteps = isWeekend ? 12000 : 8000;
      const variation = Math.random() * 4000 - 2000;
      const dailySteps = Math.max(1000, Math.floor(baseSteps + variation));
      
      steps.push({
        timestamp: timestamp,
        steps: dailySteps
      });
    }
    
    return steps;
  }

  // Generate demo workouts data
  generateDemoWorkouts(startDate, endDate) {
    const workouts = [];
    const oneDay = 24 * 60 * 60 * 1000;
    const sportTypes = ['running', 'cycling', 'swimming', 'gym', 'yoga', 'walking'];
    
    for (let timestamp = startDate; timestamp <= endDate; timestamp += oneDay) {
      const workoutProbability = Math.random() < 0.3; // 30% chance
      
      if (workoutProbability) {
        const sportType = sportTypes[Math.floor(Math.random() * sportTypes.length)];
        const duration = 30 + Math.floor(Math.random() * 60); // 30-90 minutes
        const startTime = timestamp + (Math.random() * 16 * 60 * 60 * 1000); // Random time during day
        const endTime = startTime + (duration * 60 * 1000);
        
        workouts.push({
          sport_type: sportType,
          start_time: startTime,
          end_time: endTime,
          duration: duration,
          calories: Math.floor(duration * 8), // Rough estimate
          distance: sportType === 'running' ? duration * 0.2 : 0 // Rough estimate
        });
      }
    }
    
    return workouts;
  }

  // Quick import methods
  async importLast30Days(dataTypes = ['all']) {
    const endDate = Date.now();
    const startDate = endDate - (30 * 24 * 60 * 60 * 1000);
    return await this.importHealthData(startDate, endDate, dataTypes);
  }

  async importLastWeek(dataTypes = ['all']) {
    const endDate = Date.now();
    const startDate = endDate - (7 * 24 * 60 * 60 * 1000);
    return await this.importHealthData(startDate, endDate, dataTypes);
  }
}

// Singleton instance
const healthConnectService = new HealthConnectService();
export default healthConnectService;